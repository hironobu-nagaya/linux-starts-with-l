chapter=2
story=41
title=コマンド置換
keyword=command substitution
keyword=nproc
prev=2/40/
prev-title=シェル変数
next=2/42/
next-title=算術式展開

# コマンド置換

みどり（通常）：
  お兄ちゃん！
  コマンドの出力を
  変数の値にしたいんだけど
  できそうでできないんだ…
  リダイレクトやパイプ、
  プロセス置換じゃないよね？
しげる（通常）：
  それは
  「コマンド置換
  (command substitution)」
  の出番だね
  コマンド出力を
  文字列にしてくれるんだ！

## バッククォートでのコマンド置換

しげる（通常）：
  `nproc` は
  CPU のコア数を表示するよ

```bash
nproc [オプション]...
```

しげる（通常）：
  重要なオプションはないので
  そのまま実行してみよう！

```bash
nproc
```

みどり（通常）：
  うん！

```console
4
```

みどり（通常）：
  このシステムには
  CPU のコアが
  4つあるんだね！
しげる（通常）：
  この結果を
  `CORES` 変数に
  保存してみよう！
みどり（通常）：
  こう書けば
  いいんだよね？

```bash
CORES=4
```

みどり（通常）：
  確かにコアの数は保存できたけど…
  これだと毎回 `nproc` で調べて
  値を指定しなきゃいけないよね
  私のやりたかったことには
  届いていない感じかな
しげる（通常）：
  そこで便利なのが
  コマンド置換だよ
  以下のようにコマンドを
  「バッククォート(`!backquote!`)」で囲むと
  コマンドの出力が
  そのまま文字列となって
  変数の値として使えるんだ

```bash
CORES="`nproc`"
```

みどり（通常）：
  これで本当に
  `CORES` の値が
  `4` になったのかな？
しげる（通常）：
  それは以下のコマンドで
  確認してみよう！

```bash
echo "$CORES"
```

みどり（驚き）：
  なるほど…
  `echo` で変数の値を
  表示して確認できるのね！

```console
4
```

みどり（笑顔）：
  本当だ！
  ちゃんと `4` と
  表示されたよ！

## `$( ... )` でのコマンド置換

しげる（通常）：
  バッククォートは
  古い書き方なんだ
  最近のシェルでは
  以下のように書くよ

```bash
CORES="$(nproc)"
```

みどり（通常）：
  こっちの書き方だと
  コマンド置換の
  始まりと終わりが
  分かりやすいね！
しげる（通常）：
  他にもクォートの入れ子も
  柔軟に解釈してくれるんだ

```bash
MESSAGE="$(echo "hello, $USER")"
```
みどり（通常）：
  ただダブルクォートの出現順で
  判断するのではなく
  `"$( ... )"` の中に
  `"hello, ..."` があると
  賢く判断してくれるんだね
しげる（通常）：
  なので可能なら `$( ... )` で
  コマンド置換を書くようにしよう！

## ダブルクォートで囲む

みどり（通常）：
  お兄ちゃんは
  シェル変数やコマンド置換を
  いつも「ダブルクォート(`"`)」で
  囲んでいるよね？
しげる（通常）：
  よく気が付いたね！
  意識的にそうしているんだ
みどり（通常）：
  そうすることで
  何かいいことが
  あるのかな？
しげる（通常）：
  「ダブルクォート(`"`)」で囲むと
  それが1つのまとまりであることが
  保証されるんだ
しげる（通常）：
  例えば `"$(コマンド)"` としたときに
  コマンドが何も出力しなくても空文字になるし
  `rmdir "$DIR"` を実行したときに
  `DIR` 変数の値が `Program Files` と
  スペースが含まれていても問題ないんだ
みどり（通常）：
  「転ばぬ先の杖」みたいだね！
  私も真似して書いてみるよ！

## まとめ

みどり（通常）：
  「コマンド置換」でコマンドの出力を
  文字列として扱う方法を学んだよ！
しげる（通常）：
  コマンド置換は高度な操作でよく使われるよ
  `$( ... )` でコマンドを文字列に置き換えよう

