chapter=2
story=34
title=パイプ
keyword=pipe
keyword=yes
keyword=shuf
prev=2/33/
prev-title=ヒアドキュメント
next=2/35/
next-title=ファイル検索

# パイプ

みどり（通常）：
  `>` で、コマンドの出力を
  ファイルに書き出して…
  `<` で、コマンドの入力を
  ファイルから読み込んで…
しげる（通常）：
  こんな場合は「パイプ(pipe)」が使えるよ
  コマンド同士が直接入出力をやりとりするんだ
みどり（驚き）：
  え？
  私がやろうとしていたような
  入出力内容を仲介するファイルを
  作らなくても済むの？

## 使い方

しげる（通常）：
  パイプはコマンドの出力を
  別のコマンドの入力に渡す仕組みだよ
  2つのコマンドの間に
  「パイプ、バーチカルバー (`|`)」を
  置くだけだよ

```bash
コマンド1 | コマンド2
```

みどり（驚き）：
  へぇ！
  そんなことができるんだ！
  なんだか面白そう！
しげる（通常）：
  `yes` は
  指定された文字列を
  出力し続けるよ

```bash
yes [文字列]
```

しげる（通常）：
  文字列の指定がなければ
  `yes` を出力するよ
  さっそく `yes` を
  実行してみよう！

```bash
yes
```

みどり（通常）：
  うん！

```console
yes
yes
yes
...
```

みどり（驚き）：
  うわっ！
  yes の出力が止まらなくなっちゃったよ！
  どうしよう？！
しげる（通常）：
  落ち着いて
  「割り込み(interruption)」操作を使おう
  キーボードから Ctrl + C を押してみて
  これで今動いているコマンドを
  強制的に停止できるよ
みどり（通常）：
  …あ、止まった！
  良かったぁ…
みどり（通常）：
  でもこの `yes` コマンド
  単体だと使い道がなさそうだよ
しげる（通常）：
  確かに `yes` 単体では便利に見えないかもね
  このコマンドはパイプと組み合わせるために
  用意されているんだ
みどり（通常）：
  ここでパイプが登場するのね！
しげる（通常）：
  たまに「yes / no」の確認を
  求めるコマンドがあるよね
みどり（通常）：
  うん、あるよ
  親切だけど手入力しないといけないから
  操作がどうしても遅くなっちゃうね
しげる（通常）：
  例えば `rm` に `-i` オプションを指定すると
  「削除してよいか」の確認を取るようになるんだ
  これを確認を求めるコマンドの代わりだと思ってね
しげる（通常）：
  そんなコマンドと`yes` を組み合わせて
  以下のように書くとどう思う？

```bash
yes | rm -i /home/midori/*
```

みどり（通常）：
  えっと…
  確認が全部「yes」って
  自動で答えてくれるってこと？
しげる（通常）：
  そのとおり！
  確認作業を自動化できるんだ
みどり（驚き）：
  すごい！
  それなら役に立ちそう！
しげる（通常）：
  Linux の基本的な考え方に
  「単純なコマンドを組み合わせて複雑な処理を作る」
  というものがあるんだ
しげる（通常）：
  その中心がパイプなんだ
  使いこなせるようになれば
  もっと自由にコマンドを
  操作できるようになるよ

## まとめ

みどり（通常）：
  今回はパイプを学んだよ！
  コマンド同士の入出力をつなげられるんだ！
しげる（通常）：
  パイプはいくつもつなげられるよ！
  以下のコマンドが何をするのか考えてみて

```bash
cat << EOF | shuf | head -n 1
大吉
中吉
中吉
小吉
小吉
小吉
吉
吉
吉
吉
EOF
```

しげる（通常）：
  `shuf` は行をランダムに並び替えるよ
  shuffle の略なんだ
しげる（通常）：
  `head` の `-n` オプションは
  指定された行数だけ表示するんだ
みどり（驚き）：
  これは…
  おみくじ？！

1. `cat` とヒアドキュメントで複数行を生成
2. `shuf` で行をランダムに並び替え
3. `head -n 1` で先頭の1行だけ表示

しげる（通常）：
  そのとおり！
  こんな風にパイプを活用すれば
  いろんなアイデアを
  簡単に実現できるよ
みどり（笑顔）：
  お兄ちゃん！
  これ単純だけどすっごく楽しい！
  履歴で何回も呼び出せて遊べちゃう！

