chapter=3
story=16
title=オプション処理
keyword=shell script
keyword=getopts
prev=3/15/
prev-title=引数処理
next=3/17/
next-title=readonlyコマンド

# オプション処理

しげる（通常）：
  悩みながら
  シェルスクリプトを
  書いているみたいだね？
みどり（通常）：
  うん
  オプションを
  扱えるように
  できないかと
  思っているんだけど
  これが難しくて…
しげる（通常）：
  引数を扱えるなら
  オプションも扱いたいと
  考えるのはもっともだよね
しげる（笑顔）：
  実はオプションを
  楽に解釈する仕組みが
  用意されているんだ！
みどり（驚き）：
  えっ！
  教えて欲しい！

## オプション解析スクリプト

しげる（通常）：
  `getopts` は
  オプション解析コマンドだよ
みどり（驚き）：
  専用のコマンドが
  あるんだね！
しげる（通常）：
  `getopts` は
  色々な要素と組み合わせて
  動く前提のコマンドなんだ
しげる（通常）：
  少し複雑なので
  一緒にスクリプトを
  読みながら理解しよう
しげる（通常）：
  まずはオプションを解析する
  `check-opts` スクリプトを
  作成しよう！

```bash
vim check-opts
```

みどり（通常）：
  うん！
しげる（通常）：
  そこに以下の内容を書いてね
  コメントは動作に
  影響しないから
  省略しても構わないよ

```bash
#!/bin/bash

!start-class-silver!# 初期状態!end!
OPT_A=off
OPT_B=off
OPT_C=off
OPT_C_VALUE=

!start-class-silver!# オプションを処理!end!
while getopts "abc:" OPT
do
  case "$OPT" in
    a) !start-class-silver!# a オプション!end!
      OPT_A=on
      ;;
    b) !start-class-silver!# b オプション!end!
      OPT_B=on
      ;;
    c) !start-class-silver!# c オプション（引数付き）!end!
      OPT_C=on
      OPT_C_VALUE="$OPTARG"
      ;;
    *) !start-class-silver!# 不正なオプション!end!
      echo "エラー: 無効なオプション $OPT が指定されました" >&2
      exit 1
      ;;
  esac
done

!start-class-silver!# オプション処理結果を表示!end!
echo "オプションa: $OPT_A"
echo "オプションb: $OPT_B"
echo "オプションc: $OPT_C"
[ "$OPT_C" == "on" ] && echo "オプションc値: $OPT_C_VALUE"

!start-class-silver!# 引数を処理!end!
shift $((OPTIND - 1))
for ARG in "$@"
do
  echo "引数: $ARG"
done
echo "引数の個数: $#"
```

みどり（通常）：
  ちょっと
  長かったけど
  書けたよ！
しげる（通常）：
  そうしたら
  スクリプトに
  実行権限を与えて
  実行できるようにしよう

```bash
chmod a+x check-opts
```

みどり（通常）：
  これで実行する
  準備ができたね！
みどり（通常）：
  名前のとおり
  オプションを確認
  するんだよね？
  どんなオプションを
  指定すればよいかな？
しげる（通常）：
  このスクリプトは
  `-a`, `-b`, `-c` オプションを認識するよ
  `-c` は、`head -n 1` のように
  「オプション引数」を受け取るんだ
しげる（通常）：
  オプションの指定が
  終わった後の要素は
  引数と判断してくれるよ
しげる（通常）：
  書式は以下のような感じだよ

```manpage
./check-opts [-a] [-b] [-c 値] [引数]...
```

みどり（驚き）：
  へぇ…
  いくつか
  試してみるね！

```console
./check-opts -a
オプションa: on
オプションb: off
オプションc: off
引数の個数: 0
```

```console
./check-opts -ab
オプションa: on
オプションb: on
オプションc: off
引数の個数: 0
```

```console
./check-opts -c X aaa bbb ccc
オプションa: off
オプションb: off
オプションc: on
オプションc値: X
引数: aaa
引数: bbb
引数: ccc
引数の個数: 3
```

みどり（驚き）：
  すごい！
  オプションと引数を
  ちゃんと解析できてる！
  ショートオプションの
  同時指定もバッチリ！

## getopts コマンド

しげる（通常）：
  `getopts` は
  以下の書式で使うよ

```bash
getopts オプション文字列 変数名
```

しげる（通常）：
  オプション文字列には
  ショートオプションとして
  認識する文字を並べるんだ
しげる（通常）：
  オプション文字の後に
  `:` を指定すると
  そのオプションは
  引数を取ると解釈されるんだ
みどり（通常）：
  ここの指定は `abc:` だよね

```bash
getopts "abc:" OPT
```

みどり（通常）：
  だから `-a`, `-b`, `-c` オプションを認識して
  `-c` オプションは
  オプション引数を取るんだね
しげる（通常）：
  続く変数名の変数に
  解析したオプション文字が代入されるよ
  これを`case`文で処理を分けてあげれば
  オプションごとに処理を書ける
  というわけなんだ
みどり（通常）：
  オプションが指定されていれば
  対応する変数の値を
  `off` から `on` にしているんだね
しげる（通常）：
  オプション引数が指定されていた場合
  `OPTARG` 変数にその値が代入されるよ
  この変数を参照することで
  どんな値が指定されたかがわかるんだ
しげる（通常）：
  `getopts` は
  オプション解析を
  続けられるなら成功
  そうでないなら失敗を返すんだ
  だから `getopts` は
  `while`文と一緒に使われるよ
みどり（通常）：
  `while`文の後に
  `shift` を実行しているね？
しげる（通常）：
  `OPTIND` 変数には
 `getopts` が 現在解析している
  引数の番号が入っているんだ
  1 から始まり
  次の要素の解析に移る時に
  値が 1 増加するよ
しげる（通常）：
  だからwhile 文を終えたときの `OPTIND` 変数には
  オプション解析が終わったときの引数の番号
  つまり「最後のオプション + 1」番目の
  引数の番号が入っていることになるよ
みどり（通常）：
  そこで `shift $((OPTIND - 1))` を実行すると
  解析済みのオプションを全て捨てて
  残りは全て引数というというわけなんだね…

## まとめ

みどり（通常）：
  今回は `getopts` でオプションと引数を
  解析できることを学んだよ！
  ちょっと書き方が独特で
  覚えることが多いね…
しげる（通常）：
  `getopts` は今回書いたような
  決まりきった使い方をするんだ
  最初は今回のスクリプトを雛形にして
  自分のスクリプト用に
  内容を書き換えてあげるといいよ！

