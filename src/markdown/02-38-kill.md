chapter=2
story=38
title=プロセス操作
keyword=signal
keyword=kill
keyword=nohup
prev=2/37/
prev-title=プロセス
next=2/39/
next-title=プロセス優先度

# プロセス操作

みどり（通常）：
  前回はプロセスを
  教えてもらったね！
しげる（通常）：
  今回はそのプロセスの
  管理方法を学んでいこう！

## シグナル

しげる（通常）：
  プロセスは
  「シグナル(signal)」という
  信号を送って管理するんだ
みどり（通常）：
  信号でプロセスに
  「こうして欲しい」って
  伝えるんだね
しげる（通常）：
  よく使うシグナルには
  こんな種類があるよ

シグナル名 | シグナル番号 | 意味
---------- | ------------ | ----
SIGTERM    | 15           | 終了
SIGKILL    | 9            | 強制終了
SIGHUP     | 1            | 端末の接続切れを通知
SIGINT     | 2            | キーボード割り込み(Ctrl + C)
SIGQUIT    | 3            | キーボード中止(Ctrl + /)
SIGTSTP    | 20           | 一時停止(Ctrl + Z)

みどり（驚き）：
  へぇ！
  「Ctrl + C」って
  実はシグナルを
  送っていたんだ！

## `kill` コマンド

しげる（通常）：
  `kill` は
  プロセスにシグナルを送信するよ

```bash
kill [オプション]... PID...
```

みどり（驚き）：
  「kill(殺す)」って名前…
  ちょっと怖いね
しげる（通常）：
  プロセスを止める用途がほとんどなので
  この名前なんだろうね
  確かに物騒な名前だけど
  ただプロセスにシグナルを
  送信しているだけなんだ
しげる（通常）：
  では
  実際に `kill` を
  使ってみよう！
しげる（通常）：
  まずは動いている
  プロセスを用意するよ
  以下のコマンドを実行しよう

```bash
sleep 1000 &
```

みどり（通常）：
  `&` はバックグラウンドで
  コマンドで動かすんだよね
  実行したよ！

```console
[1] 5717
```

みどり（通常）：
  ジョブ番号と…
  他に数字が出てきたね
しげる（通常）：
  この数字「5717」が
  プロセスの PID だよ
  `ps` で確認してみよう！

```bash
ps
```

みどり（通常）：
  うん！

```console
 PID TTY                TIME CMD
5173 09:28 pts/0    00:00:00 -bash
5717 13:00 pts/0    00:00:00 sleep
5720 13:02 pts/0    00:00:00 ps
```

みどり（通常）：
  確かに `sleep` の
  PID が `5717` だね！
しげる（通常）：
  では `kill` を実行して
  `sleep` プロセスに止まるよう
  シグナルを送ろう！

```bash
kill 5717
```

みどり（通常）：
  えいっ！
しげる（通常）：
  では終了したかどうか
  `ps` で確認してみよう

```bash
ps
```

みどり（通常）：
  プロセスが止まるということは
  その表示が無くなるんだよね？

```console
 PID TTY                TIME CMD
5173 09:28 pts/0    00:00:00 -bash
5723 13:05 pts/0    00:00:00 ps
```

みどり（通常）：
  `sleep` が消えているね
  プロセスが終了したんだ！
しげる（通常）：
  `kill` で送信する
  シグナルは指定できるよ
  指定がなければ「SIGTERM」が送信されるんだ
  強制終了用の「SIGKILL」を送るには
  以下のようにするよ

シグナル指定方法 | `kill` コマンド
---------------- | ---------------
シグナル番号     | `kill -9 5717`
シグナル名       | `kill -SIGKILL 5717`
短縮シグナル名   | `kill -KILL 5717`

みどり（通常）：
  シグナル一覧の
  確認はどうするのかな？
しげる（通常）：
  `kill` の ` -l` オプションで
  確認できるよ！

```bash
kill -l
```

## ジョブ番号の指定

しげる（通常）：
  PID を扱うコマンドの多くは
  PID の代わりに
  ジョブ番号を指定できるんだ
  PID の代わりに `%ジョブ番号` と
  記述するだけだよ
みどり（通常）：
  へぇ…
  柔軟なんだね！

## `nohup` コマンド

みどり（通常）：
  そういえば前回に出ていた
  プロセスの親子関係の話が
  出てこなかったね？
しげる（笑顔）：
  ちゃんと覚えていて
  くれたんだね
しげる（通常）：
  親プロセスを終了すると
  その子プロセスに
  SIGHUP が送られるんだ
  だから親プロセスが終了すると
  子プロセスも一緒に
  終了しちゃうことが多いんだよ
みどり（通常）：
  基本的に親プロセスを止めれば
  子プロセスも止まってくれるんだね
しげる（通常）：
  複数のプロセスを
  まとめて止めたいときに
  この親子関係が
  便利な場合があるんだ
みどり（通常）：
  でも…
  シェルから動かしたコマンドは
  そのシェルの子プロセスだよね？
  シェルが終わると
  それらのコマンドも
  一緒に終わっちゃわないかな？
しげる（通常）：
  基本的にはそうなるよ
  リモート接続から
  コマンドを実行していたけど
  接続が切れると
  コマンドが終わってしまうのは
  こういうわけなんだ
みどり（通常）：
  ネットワークが安定していないと
  コマンドがいつ終了しちゃうか
  ヒヤヒヤするね…
しげる（通常）：
  そういうときに便利なのが `nohup` だよ
  `nohup` から実行されたコマンドは
  SIGHUP を受け取らなくなるんだ

```bash
nohup コマンド
```

みどり（通常）：
  リモート操作をするときは
  `nohup` があることを
  覚えておくね！

## まとめ

みどり（通常）：
  今回はプロセスの管理方法を学んだよ！
  `kill` で暴走したプログラムを止めたり
  `nohup` で長期間動かすタスクを
  安心して放置できるようにするんだね
しげる（通常）：
  プロセス管理の知識は
  Linux を扱う上で重要だよ！

