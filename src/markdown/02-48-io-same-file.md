chapter=2
story=48
title=同一ファイルへの入出力
prev=2/47/
prev-title=グルーピング
next=2/49/
next-title=ハッシュ(基本)

# 同一ファイルへの入出力

みどり（通常）：
  お兄ちゃん！
  入力リダイレクト `<` と
  出力リダイレクト `>` を
  同じファイルで
  同時に使おうとすると
  おかしなことになるんだ！
みどり（通常）：
  まずは
  以下のコマンドで
  ファイルを作ったよ

```bash
cat > list << EOF
1
2
3
4
5
EOF
```

みどり（通常）：
  この内容の各行を
  シャッフルしようとして
  以下を実行したんだ

```bash
shuf < list > list
```

みどり（驚き）：
  そうしたら
  `list` ファイルの中身が
  空になっちゃったんだよ！
しげる（通常）：
  これは Linux を操作していると
  時々やってしまうことだね
  今回はこの挙動の原因の理解と
  それを解消する方法を学ぼう！

## 原因

しげる（通常）：
  ファイルの中身が
  空になった原因は
  出力リダイレクト `>` だよ
みどり（通常）：
  ファイルの中身を上書きする
  出力リダイレクトだよね！
しげる（通常）：
  出力リダイレクト `>` が使われると
  最初にファイルの中身が空にされるんだ
  リダイレクトの順序に関係なく
  出力リダイレクト先のファイルが
  真っ先に空にされるよ
みどり（驚き）：
  なるほど！
  入力リダイレクト `<` で
  `list` ファイルの内容を
  読み込んでいるけど
  この時点ですでに
  内容が空だったんだね！
しげる（通常）：
  そういうことだね
  空の内容をシャッフルしても
  その結果は空のままだよね
  その空の内容を書き出したので
  最終的に `list` の中身は
  空というわけなんだ

## 解決法

みどり（通常）：
  この問題はどうやって
  解消したらいいんだろうね？
しげる（通常）：
  入力と出力リダイレクトで
  同じファイルを指定しなければ
  この問題を解消できるよ
  いくつか方法があるので
  見てみよう！

## 一時ファイルを作る

しげる（通常）：
  コマンドを分割して
  入力と出力リダイレクトを
  同時に使わないようにすれば
  期待どおりに動作するよ
しげる（通常）：
  以下のようにしてみよう

```bash
shuf < list > list.output
mv list{.output,}
```

みどり（通常）：
  入力リダイレクトの対象は `list` で
  出力リダイレクトの対象は `list.output` だね
  入出力リダイレクトで
  それぞれ別のファイルを指定することで
  問題を回避しているんだ！
みどり（通常）：
  その後 `mv` で
  `list.output` を `list` に
  移動して上書きしているね
  操作を二段階に分けて
  やりたいことを
  実現しているんだ！
しげる（通常）：
  Linux に慣れていないなら
  この方法がわかりやすくて
  おすすめだよ

## `tee` を使う

しげる（通常）：
  `tee` は
  標準出力とファイルの
  二つへ出力を書き込むよ
  T字路の分岐みたいだから
  この名前なんだ

```bash
tee [オプション]... [ファイル]...
```

みどり（通常）：
  画面にもファイルにも出力…
  欲張りさんなコマンドだね！
しげる（通常）：
  動作を確かめるために
  以下のコマンドを
  実行してみよう！

```bash
tee ~/tee-outout <<< hello
```

みどり（通常）：
  まずは画面に
  `hello` が
  出るはずだよね？

```console
hello
```

みどり（通常）：
  よし！
  画面出力は
  確認できたね！
しげる（通常）：
  もう一つの
  出力先も見てみよう
  引数で指定した
  `~/tee-outout` ファイルだね

```bash
cat ~/tee-outout
```

みどり（通常）：
  こっちにも同じ内容が
  書かれていると思うよ！

```console
hello
```

しげる（通常）：
  この `tee` を
  出力リダイレクトの
  代わりに使うことで
  問題を解決できるよ

```bash
shuf < list | tee list
```

みどり（通常）：
  なるほど！
  出力リダイレクトを使わず
  代わりに `tee` を使うことで
  出力リダイレクト先が
  空になるという挙動を
  回避しているんだね！
みどり（通常）：
  期待どおりに動いたけど
  ファイル内容が
  標準出力にも
  表示されちゃうね
  ちょっと気になるかも
しげる（通常）：
  確かにそう感じるよね
  でも画面に内容が
  表示されても害はないし
  簡単に対処できる方法なんだ
しげる（笑顔）：
  どうしても気になるなら
  画面出力を `/dev/null` へ
  リダイレクトしよう！

## グルーピングを使う

しげる（通常）：
  最後はグルーピングを使う方法だよ

```bash
{
  rm list
  cat | shuf > list
} < list
```

しげる（通常）：
  先に言っておくけど
  複雑で難しいので
  無理に使う必要はないよ
みどり（驚き）：
  な…
  何が何だか
  わからないよ！
みどり（通常）：
  とりあえずわかりそうな
  所から見ていくね
  グルーピング `{ ... }` の中で
  `rm` を使っているけど
  どうしてファイルを
  削除しているのかな？
しげる（通常）：
  ファイルを削除することで
  その後の出力リダイレクト
  `shuf > list` が
  「新しいファイル `list` に書き出す」
  という動作になるんだ
  入力リダイレクト `< list` と
  ファイル名は同じだけど
  入出力リダイレクトで
  別ファイルを指定しているという
  動作をさせるために使っているよ
みどり（通常）：
  `cat` を引数なしで
  使っているみたいだけど
  これはどういう
  動きをするのかな？
しげる（通常）：
  `cat` を引数なしで実行すると
  読み込む内容を
  標準入力から受け付けるよ
  グルーピング `{ ... }` の外の
  入力リダイレクト `< list`
  から入力を読み込み
  パイプで次のコマンドに
  その内容を渡しているんだ
しげる（通常）：
  かなりトリッキーな方法なので
  理屈はわからなくて大丈夫だよ
  この方法を使うつもりなら
  書き方で覚えてしまおう！

## まとめ

みどり（通常）：
  今回は
  入力と出力リダイレクトを
  同時に使うときに
  同じファイルを指定すると
  期待通りに動かないことを学んだよ
  この問題を避けるには
  いくつか方法があるんだ！
しげる（通常）：
  「入力」と「出力リダイレクト」で
  同じファイルを指定していれば
  この問題は発生するよ
しげる（通常）：
  例えば以下の例でも
  同じことが起こるんだ

```bash
cat list > list
```

みどり（通常）：
  結構簡単に起こってしまうんだね…
  知らないうちにやってしまいそう
しげる（通常）：
  コマンド実行で
  目的のファイルが
  空ファイルになっていたら
  今回の挙動を疑ってみよう！

