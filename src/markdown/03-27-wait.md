chapter=3
story=27
title=ジョブ管理
keyword=shell script
keyword=wait
prev=3/26/
prev-title=シグナル処理
next=3/28/
next-title=execコマンド

# ジョブ管理

みどり（通常）：
  お兄ちゃん！
  シェルスクリプトの中でも
  バックグラウンド実行できるんだね！
しげる（通常）：
  そうだね
  スクリプトの記述と
  ジョブが並列に動けば
  効率よく処理できる
  場合があるんだ
  特に時間のかかる処理を
  ジョブにすると有効だよ
みどり（通常）：
  でもシェルスクリプトが終了しても
  ジョブはまだ動いている場合があるんだ
  スクリプト実行が終わっているのに
  実際はまだ処理が続いているというのは
  なんだか落ち着かないよ…
しげる（通常）：
  それなら今回は
  シェルスクリプトでの
  ジョブ管理を学ぼう！

## `!` 変数

しげる（通常）：
  `!` 変数には
  「直前に動かしたジョブのPID」
  が入っているよ！
みどり（通常）：
  シェル上でバックグラウンド実行すると
  「ジョブ番号」「PID」が
  表示されていたよね
  `!` 変数でも PID を知れるんだ！
しげる（通常）：
  こんなふうに使うよ

```bash
sleep 60 &
PID="$!"
```

みどり（通常）：
  ジョブの PID を `PID` 変数に
  代入しているんだね！
  PID さえ知れたら
  `kill` などで操作ができるよ！

## `wait` コマンド

しげる（通常）：
  `wait` は
  指定された PID のプロセスが
  全て終了するまで待機するよ

```bash
wait [オプション]... PID...
```

みどり（通常）：
  つまり `wait` をスクリプト内で使えば
  ジョブが完了するまで待機できるんだね！
しげる（通常）：
  そういうことだね
  ではバックグランド実行と
  `wait` を使った例を見てみよう！

```bash
#!/bin/bash

!start-class-silver!# 時間のかかる処理の代わりをする関数!end!
function heavy-task() {
  sleep "$((10 + (RANDOM % 10)))"
}

for COUNT in {1..10}
do
  heavy-task &
  PIDS="$PIDS${PIDS:+ }$!"
done

wait $PIDS
```

みどり（通常）：
  重い処理をする関数を
  `for`文で10回繰り返して
  いるんだね！
みどり（通常）：
  `PIDS` の値で
  変数展開を使っているね
  読み解くと `PIDS` の値は
  ジョブの PID がスペース区切りで
  並ぶことになるんだ！
しげる（通常）：
  そのとおり！
  最後に `wait $PIDS` で
  指定された PID を持つプロセス全てが
  終わるまで待機してから
  スクリプトを終了するんだ
みどり（笑顔）：
  これならスクリプトが終了した後も
  ジョブが動き続けるということは
  なくなるんだね！

## まとめ

みどり（通常）：
  今回はシェルスクリプトでの
  バックグラウンド実行を学んだよ！
  `!` 変数と `wait` を使って
  ジョブが終わるまで待機できるんだ！
しげる（通常）：
  最近は CPU のコアが
  複数ある場合がほとんどだよ
  バックグラウンド実行を使って
  効率良く処理を進めよう！

